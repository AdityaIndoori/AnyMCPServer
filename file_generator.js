// Function to generate README content using string joining
function generateReadmeContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name || 'my-mcp-server';
    const lines = [
        `# ${safeServerName} - MCP Server`,
        '',
        'This MCP server was generated by the MCP Server Generator web application.',
        '',
        '## Files Included',
        '',
        '*   `package.json`: Defines project metadata, dependencies, and scripts.',
        '*   `tsconfig.json`: Configures the TypeScript compiler.',
        '*   `src/index.ts`: **This is the main server code. You need to edit this file.**',
        '',
        '## Getting Started',
        '',
        'Follow these steps to complete and run your server:',
        '',
        '**1. Setup:**',
        '',
        '*   Ensure you have [Node.js](https://nodejs.org/) (version 18 or higher recommended) and npm installed.',
        '*   Place the downloaded `index.ts` file inside the `src/` directory within this project folder.',
        '*   Open a terminal or command prompt in this project folder.',
        '*   Run `npm install` to download the necessary dependencies (@modelcontextprotocol/sdk, zod, typescript, etc.).',
        '',
        '**2. Implement Tool Logic:**',
        '',
        '*   Open `src/index.ts` in your code editor.',
        '*   Find the sections marked with `/* TODO: IMPLEMENT YOUR TOOL LOGIC HERE */`.',
        '*   For each tool you defined:'
    ];

    if (toolsData.length > 0) {
        toolsData.forEach(tool => {
            const safeToolName = tool.name || 'unnamed_tool';
            lines.push('    *   **Tool: `' + safeToolName + '`**: Replace the placeholder logic inside the `(args: any) => { ... }` function with the actual code your tool needs to execute.');
        });
    } else {
        lines.push('    *   You haven\'t defined any tools yet. You can add them manually following the pattern in `index.ts` or regenerate the server.');
    }

    lines.push(
        '',
        '*   **Return Value:** Your tool logic *must* return an object matching the MCP specification:',
        '    *   **On Success:** Return `{ content: [{ type: "text", text: "Your result here" }], isError: false }`. The `content` array can hold different types as per the spec, but text is common.',
        '    *   **On Failure:** Return `{ content: [{ type: "text", text: "Error description here" }], isError: true }`.',
        '',
        '**3. Build the Server:**',
        '',
        '*   Run `npm run build`. This command uses TypeScript (`tsc`) to compile your code from `src/index.ts` into JavaScript in the `build/` directory.',
        '',
        '**4. Run the Server:**',
        '',
        '*   Run `npm run start`.',
        '*   You should see a message like "' + safeServerName + ' MCP Server (v' + (serverInfo.version || '0.1.0') + ') running on stdio".',
        '*   The server is now running and waiting for an MCP client (like Claude Desktop) to connect via standard input/output.',
        '',
        '**5. Connecting to a Client (Example: Claude Desktop):**',
        '',
        '*   To use this server with Claude Desktop, you need to add it to the Claude configuration file (`claude_desktop_config.json`). See the [MCP Quickstart for Claude Users](https://modelcontextprotocol.io/quickstart/user) or [Server Developers](https://modelcontextprotocol.io/quickstart/server) for details on how to configure the `command` and `args` to run your server (using `node build/index.js` or potentially `npm run start` depending on your setup). Remember to use the **absolute path** to your project directory in the configuration.'
    );

    return lines.join('\n');
}

// Function to generate index.ts content using string joining/concatenation
function generateIndexTsContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name?.replace(/"/g, '\\"') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version?.replace(/"/g, '\\"') || '0.1.0';

    const header = [
        '#!/usr/bin/env node',
        'import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
        'import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";',
        toolsData.length > 0 ? 'import { z } from "zod";' : '',
        '',
        'const server = new McpServer({',
        '    name: "' + safeServerName + '",',
        '    version: "' + safeServerVersion + '",',
        '    capabilities: {',
        '        resources: {}, // Add resource capabilities if needed later',
        '        tools: {},     // Tool capabilities enabled by default when tools are added',
        '    },',
        '});',
        '',
        '// --- Tool Definitions ---',
        ''
    ];

    const toolDefinitions = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/"/g, '\\"') || 'unnamed_tool';
        const safeToolDesc = tool.description?.replace(/"/g, '\\"') || 'No description';
        let schemaParts = [];

        tool.params.forEach(param => {
            const safeParamName = param.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_param';
            let zodType;
            switch (param.type) {
                case 'number': zodType = 'z.number()'; break;
                case 'boolean': zodType = 'z.boolean()'; break;
                case 'string':
                default: zodType = 'z.string()'; break;
            }
            if (!param.required) {
                zodType += '.optional()';
            }
            schemaParts.push('    ' + safeParamName + ': ' + zodType);
        });

        const schemaString = schemaParts.length > 0 ? '{\n' + schemaParts.join(',\n') + '\n}' : '{}';
        const toolHandler = [
            'server.tool(',
            '    "' + safeToolName + '",',
            '    "' + safeToolDesc + '",',
            '    ' + schemaString + ',',
            '    // Simplified placeholder handler',
            '    (args: any) => {',
            '        /* TODO: IMPLEMENT YOUR TOOL LOGIC FOR \'' + safeToolName + '\' HERE.',
            '         * See the generated README.md for detailed instructions.',
            '         * Access parameters via the \'args\' object (e.g., args.' + (tool.params[0]?.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'param1') + ').',
            '         * Remember to handle potential errors using try...catch.',
            '         * Return an object like:',
            '         *   { content: [{ type: "text", text: "Success result" }], isError: false }',
            '         * or on error:',
            '         *   { content: [{ type: "text", text: "Error message" }], isError: true }',
            '         */',
            '',
            '        console.log("Executing tool \'' + safeToolName + '\' with input:", args);',
            '',
            '        // --- VERY BASIC PLACEHOLDER ---',
            '        // Replace this entire block with your actual logic and error handling',
            '        const placeholderResult = "Placeholder result for ' + safeToolName + '";',
            '        return {',
            '            content: [{ type: "text", text: placeholderResult }],',
            '            isError: false',
            '        };',
            '        // --- END BASIC PLACEHOLDER ---',
            '    }',
            ');',
            ''
        ];
        return toolHandler.join('\n');
    });

    const footer = [
        '',
        '// --- Server Startup ---',
        'async function main() {',
        '    const transport = new StdioServerTransport();',
        '    try {',
        '        await server.connect(transport);',
        '        console.error("' + safeServerName + ' MCP Server (v' + safeServerVersion + ') running on stdio");',
        '    } catch (error) {',
        '        console.error("Failed to connect server:", error);',
        '        process.exit(1);',
        '    }',
        '}',
        '',
        'main().catch((error) => {',
        '    console.error("Fatal error:", error);',
        '    process.exit(1);',
        '});',
        ''
    ];

    return header.join('\n') + toolDefinitions.join('\n') + footer.join('\n');
}

// Function to generate package.json content
function generatePackageJsonContent(serverInfo) {
    const safeServerName = serverInfo.name?.toLowerCase().replace(/[^a-z0-9-]/g, '-') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version || '0.1.0';

    const content = {
        name: safeServerName,
        version: safeServerVersion,
        type: "module",
        description: "MCP server '" + (serverInfo.name || 'N/A') + "' generated by MCP Server Generator",
        main: "build/index.js",
        bin: {
            [safeServerName]: "./build/index.js"
        },
        scripts: {
            "build": "tsc",
            "start": "node build/index.js"
        },
        dependencies: {
            "@modelcontextprotocol/sdk": "^1.7.0",
            "zod": "^3.23.8"
        },
        devDependencies: {
            "typescript": "^5.4.5",
            "@types/node": "^20.12.12"
        },
        engines: {
            "node": ">=18.0.0"
        },
        author: "MCP Server Generator",
        license: "ISC"
    };
    return JSON.stringify(content, null, 2);
}

// Function to generate tsconfig.json content
function generateTsconfigJsonContent() {
    const content = {
        compilerOptions: {
            target: "ES2022",
            module: "Node16",
            moduleResolution: "Node16",
            outDir: "./build",
            rootDir: "./src",
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "build"]
    };
    return JSON.stringify(content, null, 2);
}

// Global variable to store generated file data for zipping
let generatedFilesData = null;

// Main function to generate all files
function generateFiles() {
    console.log("Gathering data and generating files...");
    // const downloadLinksDiv = document.getElementById('download-links'); // No longer needed for links
    const indexTsPreview = document.getElementById('index-ts-preview');
    const downloadAllButton = document.getElementById('download-all-button'); // Get the new button

    if (!indexTsPreview || !downloadAllButton) { // Check for new button
        console.error("Required elements (index-ts-preview or download-all-button) not found.");
        return;
    }
    // downloadLinksDiv.innerHTML = ''; // Clear previous links - No longer needed
    indexTsPreview.value = ''; // Clear preview
    downloadAllButton.style.display = 'none'; // Hide button initially
    generatedFilesData = null; // Reset stored data

    // 1. Gather Data
    const serverNameInput = document.getElementById('server-name');
    const serverVersionInput = document.getElementById('server-version');

    const serverInfo = {
        name: serverNameInput ? serverNameInput.value.trim() : 'my-mcp-server',
        version: serverVersionInput ? serverVersionInput.value.trim() : '0.1.0'
    };
     if (!serverInfo.name) {
        alert("Server Name cannot be empty.");
        downloadLinksDiv.innerHTML = '<p style="color: red;">Server Name cannot be empty.</p>';
        return;
    }

    const toolsData = [];
    document.querySelectorAll('.tool-definition').forEach(toolDiv => {
        const toolId = toolDiv.id;
        const toolNameInput = document.getElementById(toolId + '-name'); // Fixed template literal issue
        const toolDescInput = document.getElementById(toolId + '-desc'); // Fixed template literal issue
        const tool = {
            name: toolNameInput ? toolNameInput.value.trim() : 'tool_' + toolId, // Fixed template literal issue
            description: toolDescInput ? toolDescInput.value.trim() : '',
            params: []
        };
        if (!tool.name) {
            alert('Tool name for Tool ' + toolId.split('-')[1] + ' cannot be empty.'); // Fixed template literal issue
            tool.name = 'invalid_tool_' + toolId; // Fixed template literal issue
        }

        toolDiv.querySelectorAll('.parameter-definition').forEach(paramDiv => {
            const paramId = paramDiv.id;
            const paramNameInput = document.getElementById(paramId + '-name'); // Fixed template literal issue
            const paramTypeSelect = document.getElementById(paramId + '-type'); // Fixed template literal issue
            const paramRequiredCheckbox = document.getElementById(paramId + '-required'); // Fixed template literal issue

            const paramData = {
                name: paramNameInput ? paramNameInput.value.trim() : 'param_' + paramId, // Fixed template literal issue
                type: paramTypeSelect ? paramTypeSelect.value : 'string',
                required: paramRequiredCheckbox ? paramRequiredCheckbox.checked : true,
            };
            if (!paramData.name) {
                 alert('Parameter name for Param ' + paramId.split('-')[1] + ' in Tool \'' + tool.name + '\' cannot be empty.'); // Fixed template literal issue
                 paramData.name = 'invalid_param_' + paramId; // Fixed template literal issue
            }
            tool.params.push(paramData);
        });
        toolsData.push(tool);
    });

    // 2. Generate Content
    try {
        const indexTsContent = generateIndexTsContent(serverInfo, toolsData);
        const packageJsonContent = generatePackageJsonContent(serverInfo);
        const tsconfigJsonContent = generateTsconfigJsonContent();
        const readmeContent = generateReadmeContent(serverInfo, toolsData);

        // 3. Populate Preview
        indexTsPreview.value = indexTsContent;

        // 4. Store generated data for zipping
        generatedFilesData = {
            serverName: serverInfo.name || 'my-mcp-server',
            readme: readmeContent,
            packageJson: packageJsonContent,
            tsconfig: tsconfigJsonContent,
            indexTs: indexTsContent
        };

        // 5. Show the Download All button
        downloadAllButton.style.display = 'inline-block'; // Or 'block' depending on desired layout

    } catch (error) {
        console.error("Error generating files:", error);
        alert("An error occurred during file generation. Check the console for details.");
        // Display error in a more robust way if needed, e.g., dedicated error div
        const summaryDiv = document.getElementById('summary'); // Example: show error near summary
        if (summaryDiv) {
             summaryDiv.innerHTML = '<p style="color: red;">Error generating files: ' + (error instanceof Error ? error.message : String(error)) + '</p>';
        }
        generatedFilesData = null; // Ensure no partial data is available for download
        downloadAllButton.style.display = 'none'; // Hide button on error
    }
}

// Function to download all files as a zip
function downloadAllFiles() {
    if (!generatedFilesData) {
        alert("Please generate the files first.");
        return;
    }
    if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
        alert("Error: Required libraries (JSZip or FileSaver) not loaded.");
        console.error("JSZip or FileSaver not found. Make sure they are included in the HTML.");
        return;
    }

    console.log("Creating zip file...");
    try {
        const zip = new JSZip();
        const safeServerName = generatedFilesData.serverName.replace(/[^a-z0-9_-]/gi, '_'); // Sanitize name for zip file

        // Add files to zip
        zip.file("README.md", generatedFilesData.readme);
        zip.file("package.json", generatedFilesData.packageJson);
        zip.file("tsconfig.json", generatedFilesData.tsconfig);
        // Create src directory and add index.ts inside it
        zip.folder("src").file("index.ts", generatedFilesData.indexTs);

        // Generate the zip file asynchronously
        zip.generateAsync({ type: "blob" })
            .then(function(content) {
                // Trigger download using FileSaver.js
                saveAs(content, safeServerName + "_mcp_server.zip");
                console.log("Zip file download initiated.");
            })
            .catch(function (err) {
                console.error("Error generating zip file:", err);
                alert("Error creating zip file: " + err.message);
            });
    } catch (error) {
        console.error("Error during zipping process:", error);
        alert("An unexpected error occurred while creating the zip file.");
    }
}
