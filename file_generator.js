// Function to generate README content using string joining
function generateReadmeContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name || 'my-mcp-server';
    const lines = [
        `# ${safeServerName} - MCP Server`,
        '',
        'This MCP server was generated by the MCP Server Generator web application.',
        '',
        '## Files Included',
        '',
        '*   `package.json`: Defines project metadata, dependencies, and scripts.',
        '*   `tsconfig.json`: Configures the TypeScript compiler.',
        '*   `src/index.ts`: **This is the main server code. You need to edit this file.**',
        '',
        '## Getting Started',
        '',
        'Follow these steps to complete and run your server:',
        '',
        '**1. Setup:**',
        '',
        '*   Ensure you have [Node.js](https://nodejs.org/) (version 18 or higher recommended) and npm installed.',
        '*   Place the downloaded `index.ts` file inside the `src/` directory within this project folder.',
        '*   Open a terminal or command prompt in this project folder.',
        '*   Run `npm install` to download the necessary dependencies (@modelcontextprotocol/sdk, zod, typescript, etc.).',
        '',
        '**2. Implement Tool Logic:**',
        '',
        '*   Open `src/index.ts` in your code editor.',
        '*   Find the sections marked with `/* TODO: IMPLEMENT YOUR TOOL LOGIC HERE */`.',
        '*   For each tool you defined:'
    ];

    if (toolsData.length > 0) {
        toolsData.forEach(tool => {
            const safeToolName = tool.name || 'unnamed_tool';
            lines.push('    *   **Tool: `' + safeToolName + '`**: Replace the placeholder logic inside the `(args: any) => { ... }` function with the actual code your tool needs to execute.');
        });
    } else {
        lines.push('    *   You haven\'t defined any tools yet. You can add them manually following the pattern in `index.ts` or regenerate the server.');
    }

    lines.push(
        '',
        '*   **Return Value:** Your tool logic *must* return an object matching the MCP specification:',
        '    *   **On Success:** Return `{ content: [{ type: "text", text: "Your result here" }], isError: false }`. The `content` array can hold different types as per the spec, but text is common.',
        '    *   **On Failure:** Return `{ content: [{ type: "text", text: "Error description here" }], isError: true }`.',
        '',
        '**3. Build the Server:**',
        '',
        '*   Run `npm run build`. This command uses TypeScript (`tsc`) to compile your code from `src/index.ts` into JavaScript in the `build/` directory.',
        '',
        '**4. Run the Server:**',
        '',
        '*   Run `npm run start`.',
        '*   You should see a message like "' + safeServerName + ' MCP Server (v' + (serverInfo.version || '0.1.0') + ') running on stdio".',
        '*   The server is now running and waiting for an MCP client (like Claude Desktop) to connect via standard input/output.',
        '',
        '**5. Connecting to a Client (Example: Claude Desktop):**',
        '',
        '*   To use this server with Claude Desktop, you need to add it to the Claude configuration file (`claude_desktop_config.json`). See the [MCP Quickstart for Claude Users](https://modelcontextprotocol.io/quickstart/user) or [Server Developers](https://modelcontextprotocol.io/quickstart/server) for details on how to configure the `command` and `args` to run your server (using `node build/index.js` or potentially `npm run start` depending on your setup). Remember to use the **absolute path** to your project directory in the configuration.'
    );

    return lines.join('\n');
}

// Function to generate index.ts content using string joining/concatenation
function generateIndexTsContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name?.replace(/"/g, '\\"') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version?.replace(/"/g, '\\"') || '0.1.0';

    const header = [
        '#!/usr/bin/env node',
        'import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
        'import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";',
        toolsData.length > 0 ? 'import { z } from "zod";' : '',
        '',
        'const server = new McpServer({',
        '    name: "' + safeServerName + '",',
        '    version: "' + safeServerVersion + '",',
        '    capabilities: {',
        '        resources: {}, // Add resource capabilities if needed later',
        '        tools: {},     // Tool capabilities enabled by default when tools are added',
        '    },',
        '});',
        '',
        '// --- Tool Definitions ---',
        ''
    ];

    const toolDefinitions = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/"/g, '\\"') || 'unnamed_tool';
        const safeToolDesc = tool.description?.replace(/"/g, '\\"') || 'No description';
        let schemaParts = [];

        tool.params.forEach(param => {
            const safeParamName = param.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_param';
            let zodType;
            switch (param.type) {
                case 'number': zodType = 'z.number()'; break;
                case 'boolean': zodType = 'z.boolean()'; break;
                case 'string':
                default: zodType = 'z.string()'; break;
            }
            if (!param.required) {
                zodType += '.optional()';
            }
            schemaParts.push('    ' + safeParamName + ': ' + zodType);
        });

        const schemaString = schemaParts.length > 0 ? '{\n' + schemaParts.join(',\n') + '\n}' : '{}';
        const toolHandler = [
            'server.tool(',
            '    "' + safeToolName + '",',
            '    "' + safeToolDesc + '",',
            '    ' + schemaString + ',',
            '    // Simplified placeholder handler',
            '    (args: any) => {',
            '        /* TODO: IMPLEMENT YOUR TOOL LOGIC FOR \'' + safeToolName + '\' HERE.',
            '         * See the generated README.md for detailed instructions.',
            '         * Access parameters via the \'args\' object (e.g., args.' + (tool.params[0]?.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'param1') + ').',
            '         * Remember to handle potential errors using try...catch.',
            '         * Return an object like:',
            '         *   { content: [{ type: "text", text: "Success result" }], isError: false }',
            '         * or on error:',
            '         *   { content: [{ type: "text", text: "Error message" }], isError: true }',
            '         */',
            '',
            '        console.log("Executing tool \'' + safeToolName + '\' with input:", args);',
            '',
            '        // --- VERY BASIC PLACEHOLDER ---',
            '        // Replace this entire block with your actual logic and error handling',
            '        const placeholderResult = "Placeholder result for ' + safeToolName + '";',
            '        return {',
            '            content: [{ type: "text", text: placeholderResult }],',
            '            isError: false',
            '        };',
            '        // --- END BASIC PLACEHOLDER ---',
            '    }',
            ');',
            ''
        ];
        return toolHandler.join('\n');
    });

    const footer = [
        '',
        '// --- Server Startup ---',
        'async function main() {',
        '    const transport = new StdioServerTransport();',
        '    try {',
        '        await server.connect(transport);',
        '        console.error("' + safeServerName + ' MCP Server (v' + safeServerVersion + ') running on stdio");',
        '    } catch (error) {',
        '        console.error("Failed to connect server:", error);',
        '        process.exit(1);',
        '    }',
        '}',
        '',
        'main().catch((error) => {',
        '    console.error("Fatal error:", error);',
        '    process.exit(1);',
        '});',
        ''
    ];

    return header.join('\n') + toolDefinitions.join('\n') + footer.join('\n');
}

// Function to generate package.json content
function generatePackageJsonContent(serverInfo) {
    const safeServerName = serverInfo.name?.toLowerCase().replace(/[^a-z0-9-]/g, '-') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version || '0.1.0';

    const content = {
        name: safeServerName,
        version: safeServerVersion,
        type: "module",
        description: "MCP server '" + (serverInfo.name || 'N/A') + "' generated by MCP Server Generator",
        main: "build/index.js",
        bin: {
            [safeServerName]: "./build/index.js"
        },
        scripts: {
            "build": "tsc",
            "start": "node build/index.js"
        },
        dependencies: {
            "@modelcontextprotocol/sdk": "^1.7.0",
            "zod": "^3.23.8"
        },
        devDependencies: {
            "typescript": "^5.4.5",
            "@types/node": "^20.12.12"
        },
        engines: {
            "node": ">=18.0.0"
        },
        author: "MCP Server Generator",
        license: "ISC"
    };
    return JSON.stringify(content, null, 2);
}

// Function to generate tsconfig.json content
function generateTsconfigJsonContent() {
    const content = {
        compilerOptions: {
            target: "ES2022",
            module: "Node16",
            moduleResolution: "Node16",
            outDir: "./build",
            rootDir: "./src",
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "build"]
    };
    return JSON.stringify(content, null, 2);
}

// Function to create download links
function createDownloadLink(filename, content, mimeType) {
    try {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.textContent = 'Download ' + filename; // Use concatenation
        return a;
    } catch (error) {
        console.error('Error creating download link for ' + filename + ':', error); // Use concatenation
        const errorP = document.createElement('p');
        errorP.style.color = 'red';
        errorP.textContent = 'Error creating download link for ' + filename + '.'; // Use concatenation
        return errorP;
    }
}

// Main function to generate all files
function generateFiles() {
    console.log("Gathering data and generating files...");
    const downloadLinksDiv = document.getElementById('download-links');
    const indexTsPreview = document.getElementById('index-ts-preview');

    if (!downloadLinksDiv || !indexTsPreview) {
        console.error("Required elements (download-links or index-ts-preview) not found.");
        return;
    }
    downloadLinksDiv.innerHTML = ''; // Clear previous links
    indexTsPreview.value = ''; // Clear preview

    // 1. Gather Data
    const serverNameInput = document.getElementById('server-name');
    const serverVersionInput = document.getElementById('server-version');

    const serverInfo = {
        name: serverNameInput ? serverNameInput.value.trim() : 'my-mcp-server',
        version: serverVersionInput ? serverVersionInput.value.trim() : '0.1.0'
    };
     if (!serverInfo.name) {
        alert("Server Name cannot be empty.");
        downloadLinksDiv.innerHTML = '<p style="color: red;">Server Name cannot be empty.</p>';
        return;
    }

    const toolsData = [];
    document.querySelectorAll('.tool-definition').forEach(toolDiv => {
        const toolId = toolDiv.id;
        const toolNameInput = document.getElementById(toolId + '-name'); // Fixed template literal issue
        const toolDescInput = document.getElementById(toolId + '-desc'); // Fixed template literal issue
        const tool = {
            name: toolNameInput ? toolNameInput.value.trim() : 'tool_' + toolId, // Fixed template literal issue
            description: toolDescInput ? toolDescInput.value.trim() : '',
            params: []
        };
        if (!tool.name) {
            alert('Tool name for Tool ' + toolId.split('-')[1] + ' cannot be empty.'); // Fixed template literal issue
            tool.name = 'invalid_tool_' + toolId; // Fixed template literal issue
        }

        toolDiv.querySelectorAll('.parameter-definition').forEach(paramDiv => {
            const paramId = paramDiv.id;
            const paramNameInput = document.getElementById(paramId + '-name'); // Fixed template literal issue
            const paramTypeSelect = document.getElementById(paramId + '-type'); // Fixed template literal issue
            const paramRequiredCheckbox = document.getElementById(paramId + '-required'); // Fixed template literal issue

            const paramData = {
                name: paramNameInput ? paramNameInput.value.trim() : 'param_' + paramId, // Fixed template literal issue
                type: paramTypeSelect ? paramTypeSelect.value : 'string',
                required: paramRequiredCheckbox ? paramRequiredCheckbox.checked : true,
            };
            if (!paramData.name) {
                 alert('Parameter name for Param ' + paramId.split('-')[1] + ' in Tool \'' + tool.name + '\' cannot be empty.'); // Fixed template literal issue
                 paramData.name = 'invalid_param_' + paramId; // Fixed template literal issue
            }
            tool.params.push(paramData);
        });
        toolsData.push(tool);
    });

    // 2. Generate Content
    try {
        const indexTsContent = generateIndexTsContent(serverInfo, toolsData);
        const packageJsonContent = generatePackageJsonContent(serverInfo);
        const tsconfigJsonContent = generateTsconfigJsonContent();
        const readmeContent = generateReadmeContent(serverInfo, toolsData);

        // 3. Populate Preview
        indexTsPreview.value = indexTsContent;

        // 4. Create Download Links
        downloadLinksDiv.appendChild(createDownloadLink('README.md', readmeContent, 'text/markdown'));
        downloadLinksDiv.appendChild(createDownloadLink('package.json', packageJsonContent, 'application/json'));
        downloadLinksDiv.appendChild(createDownloadLink('tsconfig.json', tsconfigJsonContent, 'application/json'));
        downloadLinksDiv.appendChild(createDownloadLink('index.ts', indexTsContent, 'text/typescript'));

        downloadLinksDiv.insertAdjacentHTML('beforeend', '<p><small>Download all files. Place <code>index.ts</code> inside a <code>src/</code> directory. Read <code>README.md</code> for setup and implementation instructions.</small></p>');

    } catch (error) {
        console.error("Error generating files:", error);
        alert("An error occurred during file generation. Check the console for details.");
        // Use concatenation for error message display
        downloadLinksDiv.innerHTML = '<p style="color: red;">Error generating files: ' + (error instanceof Error ? error.message : String(error)) + '</p>';
    }
}