// Function to generate README content using string joining
function generateReadmeContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name || 'my-mcp-server';
    let content = ''; // Initialize empty string

    // Add initial static content
    content += `# ${safeServerName} - MCP Server\n\n`;
    content += 'This MCP server was generated by the MCP Server Generator web application.\n\n';
    content += '## Files Included\n\n';
    content += '*   `package.json`: Defines project metadata, dependencies, and scripts.\n';
    content += '*   `tsconfig.json`: Configures the TypeScript compiler.\n';
    content += '*   `src/index.ts`: The main server entry point, imports and registers tools.\n';

    // Add dynamic tool file lines
    toolsData.forEach(tool => {
        content += `*   \`src/${tool.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_tool'}.ts\`: **Implement logic for the '${tool.name || 'unnamed_tool'}' tool here.**\n`;
    });

    // Add remaining static content
    content += '\n## Getting Started\n\n';
    content += '1.  **Install Dependencies:** Open a terminal in this project folder and run `npm install`.\n';
    content += `2.  **Implement Logic:** Edit the individual \`src/<toolName>.ts\` files (e.g., \`src/${toolsData[0]?.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'your_tool'}.ts\`) and add your code to the exported \`handle_...\` function.\n`;
    content += '    *   The function must return a Promise resolving to `{ content: [{ type: "text", text: "..." }], isError: false }` on success, or `{ ..., isError: true }` on failure.\n';
    content += '3.  **Build:** Run `npm run build` to compile the TypeScript code.\n';
    content += '4.  **Run:** Run `npm run start` to start the server.\n';
    content += '5.  **Connect Client:** Configure your MCP client (e.g., Claude Desktop `claude_desktop_config.json`) to run the server using its absolute path (e.g., `node /path/to/your/project/build/index.js`). See [MCP Docs](https://modelcontextprotocol.io/quickstart/server) for details.\n';

    return content; // Return the concatenated string
}

// Function to generate index.ts content using string joining/concatenation
function generateIndexTsContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name?.replace(/"/g, '\\"') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version?.replace(/"/g, '\\"') || '0.1.0';

    // Generate import statements for each tool handler
    const toolImports = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_tool';
        // Use .js extension for imports as they point to compiled files
        return `import { handle_${safeToolName} } from './${safeToolName}.js';`;
    }).join('\n');

    const header = [
        '#!/usr/bin/env node',
        'import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
        'import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";',
        toolsData.length > 0 ? 'import { z } from "zod";' : '',
        '',
        '// --- Tool Handler Imports ---',
        toolImports, // Add the generated imports here
        '',
        'const server = new McpServer({',
        '    name: "' + safeServerName + '",',
        '    version: "' + safeServerVersion + '",',
        '    capabilities: {',
        '        resources: {}, // Add resource capabilities if needed later',
        '        tools: {},     // Tool capabilities enabled by default when tools are added',
        '    },',
        '});',
        '',
        '// --- Tool Definitions ---',
        ''
    ];

    const toolDefinitions = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/"/g, '\\"') || 'unnamed_tool';
        const safeToolDesc = tool.description?.replace(/"/g, '\\"') || 'No description';
        let schemaParts = [];

        tool.params.forEach(param => {
            const safeParamName = param.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_param';
            let zodType;
            switch (param.type) {
                case 'number': zodType = 'z.number()'; break;
                case 'boolean': zodType = 'z.boolean()'; break;
                case 'string':
                default: zodType = 'z.string()'; break;
            }
            if (!param.required) {
                zodType += '.optional()';
            }
            schemaParts.push('    ' + safeParamName + ': ' + zodType);
        });

        const schemaString = schemaParts.length > 0 ? '{\n' + schemaParts.join(',\n') + '\n}' : '{}';
        const toolHandler = [
            'server.tool(',
            '    "' + safeToolName + '",',
            '    "' + safeToolDesc + '",',
            '    ' + schemaString + ',',
            '    // Assign the imported handler directly, with explicit return type',
            '    handle_' + safeToolName + ' as (args: any) => Promise<any>', // Use imported handler and add type assertion
            ');',
            ''
        ];
        return toolHandler.join('\n');
    });

    const footer = [
        '',
        '// --- Server Startup ---',
        'async function main() {',
        '    const transport = new StdioServerTransport();',
        '    try {',
        '        await server.connect(transport);',
        '        console.error("' + safeServerName + ' MCP Server (v' + safeServerVersion + ') running on stdio");',
        '    } catch (error) {',
        '        console.error("Failed to connect server:", error);',
        '        process.exit(1);',
        '    }',
        '}',
        '',
        'main().catch((error) => {',
        '    console.error("Fatal error:", error);',
        '    process.exit(1);',
        '});',
        ''
    ];

    return header.join('\n') + toolDefinitions.join('\n') + footer.join('\n');
}

// Function to generate package.json content
function generatePackageJsonContent(serverInfo) {
    const safeServerName = serverInfo.name?.toLowerCase().replace(/[^a-z0-9-]/g, '-') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version || '0.1.0';

    const content = {
        name: safeServerName,
        version: safeServerVersion,
        type: "module",
        description: "MCP server '" + (serverInfo.name || 'N/A') + "' generated by MCP Server Generator",
        main: "build/index.js",
        bin: {
            [safeServerName]: "./build/index.js"
        },
        scripts: {
            "build": "tsc",
            "start": "node build/index.js"
        },
        dependencies: {
            "@modelcontextprotocol/sdk": "^1.7.0",
            "zod": "^3.23.8"
        },
        devDependencies: {
            "typescript": "^5.4.5",
            "@types/node": "^20.12.12"
        },
        engines: {
            "node": ">=18.0.0"
        },
        author: "MCP Server Generator",
        license: "ISC"
    };
    return JSON.stringify(content, null, 2);
}

// NEW Function to generate content for a single tool file (e.g., src/add.ts)
function generateSingleToolFileContent(tool) {
    const safeToolName = tool.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_tool';
    const paramNames = tool.params.map(p => p.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_param');
    // Generate a basic Zod-like type hint string for the comment
    const paramsTypeHint = tool.params.map(p => `${p.name?.replace(/[^a-zA-Z0-9_]/g, '_')}${p.required ? '' : '?'}: ${p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string'}`).join(', ');
    const argsSignature = tool.params.length > 0 ? `{ ${paramNames.join(', ')} }: { ${paramsTypeHint} }` : 'args: any';

    const fileContent = [
        '// src/' + safeToolName + '.ts',
        '// Implement the logic for the \'' + (tool.name || 'unnamed_tool') + '\' tool in this file.',
        '',
        '// Import necessary modules (e.g., import fs from \'fs/promises\';)',
        '',
        `/** Handler for the '${tool.name || 'unnamed_tool'}' tool. */`,
        `export async function handle_${safeToolName}(${argsSignature}) {`,
        `    console.log("Executing '${tool.name || 'unnamed_tool'}' with:", ${tool.params.length > 0 ? `{ ${paramNames.join(', ')} }` : 'args'});`,
        '',
        '    try {',
        '        // --- Your Implementation Here ---',
        `        // Access args like: ${paramNames[0] || 'args.param1'}`,
        `        const resultValue = "Placeholder result for ${tool.name || 'unnamed_tool'}"; // Calculate result`,
        '',
        '        // On success:',
        '        return { content: [{ type: "text", text: String(resultValue) }], isError: false }; // Ensure text is a string',
        '',
        '    } catch (error) {',
        `        console.error("Error in '${tool.name || 'unnamed_tool'}':", error);`,
        '        const message = error instanceof Error ? error.message : "Unknown error";',
        '        // On failure:',
        `        return { content: [{ type: "text", text: \`Error in ${tool.name || 'unnamed_tool'}: \${message}\` }], isError: true };`,
        '    }',
        '}',
        ''
    ];
    return fileContent.join('\n');
}


// Function to generate tsconfig.json content
function generateTsconfigJsonContent() {
    const content = {
        compilerOptions: {
            target: "ES2022",
            module: "Node16",
            moduleResolution: "Node16",
            outDir: "./build",
            rootDir: "./src",
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "build"]
    };
    return JSON.stringify(content, null, 2);
}

// Global variable to store generated file data for zipping
let generatedFilesData = null;

// Main function to generate all files
function generateFiles() {
    console.log("Gathering data and generating files...");
    // const downloadLinksDiv = document.getElementById('download-links'); // No longer needed for links
    // const indexTsPreview = document.getElementById('index-ts-preview'); // Reference already removed
    const downloadAllButton = document.getElementById('download-all-button'); // Get the new button

    if (!downloadAllButton) { // Only check for download button
        console.error("Required element (download-all-button) not found.");
        return;
    }
    // downloadLinksDiv.innerHTML = ''; // Clear previous links - No longer needed
    // indexTsPreview.value = ''; // Clear preview // Removed reference
    downloadAllButton.style.display = 'none'; // Hide button initially
    generatedFilesData = null; // Reset stored data

    // 1. Gather Data
    const serverNameInput = document.getElementById('server-name');
    const serverVersionInput = document.getElementById('server-version');

    const serverInfo = {
        name: serverNameInput ? serverNameInput.value.trim() : 'my-mcp-server',
        version: serverVersionInput ? serverVersionInput.value.trim() : '0.1.0'
    };
     if (!serverInfo.name) {
        alert("Server Name cannot be empty.");
        downloadLinksDiv.innerHTML = '<p style="color: red;">Server Name cannot be empty.</p>';
        return;
    }

    const toolsData = [];
    document.querySelectorAll('.tool-definition').forEach(toolDiv => {
        const toolId = toolDiv.id;
        const toolNameInput = document.getElementById(toolId + '-name'); // Fixed template literal issue
        const toolDescInput = document.getElementById(toolId + '-desc'); // Fixed template literal issue
        const tool = {
            name: toolNameInput ? toolNameInput.value.trim() : 'tool_' + toolId, // Fixed template literal issue
            description: toolDescInput ? toolDescInput.value.trim() : '',
            params: []
        };
        if (!tool.name) {
            alert('Tool name for Tool ' + toolId.split('-')[1] + ' cannot be empty.'); // Fixed template literal issue
            tool.name = 'invalid_tool_' + toolId; // Fixed template literal issue
        }

        toolDiv.querySelectorAll('.parameter-definition').forEach(paramDiv => {
            const paramId = paramDiv.id;
            const paramNameInput = document.getElementById(paramId + '-name'); // Fixed template literal issue
            const paramTypeSelect = document.getElementById(paramId + '-type'); // Fixed template literal issue
            const paramRequiredCheckbox = document.getElementById(paramId + '-required'); // Fixed template literal issue

            const paramData = {
                name: paramNameInput ? paramNameInput.value.trim() : 'param_' + paramId, // Fixed template literal issue
                type: paramTypeSelect ? paramTypeSelect.value : 'string',
                required: paramRequiredCheckbox ? paramRequiredCheckbox.checked : true,
            };
            if (!paramData.name) {
                 alert('Parameter name for Param ' + paramId.split('-')[1] + ' in Tool \'' + tool.name + '\' cannot be empty.'); // Fixed template literal issue
                 paramData.name = 'invalid_param_' + paramId; // Fixed template literal issue
            }
            tool.params.push(paramData);
        });
        toolsData.push(tool);
    });

    // 2. Generate Content
    try {
        const indexTsContent = generateIndexTsContent(serverInfo, toolsData);
        // Removed duplicate declaration below
        const packageJsonContent = generatePackageJsonContent(serverInfo);
        const tsconfigJsonContent = generateTsconfigJsonContent();
        const readmeContent = generateReadmeContent(serverInfo, toolsData); // Pass toolsData for dynamic file list

        // Generate content for each tool file
        const toolFiles = toolsData.map(tool => {
            const safeToolName = tool.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_tool';
            return {
                filename: `src/${safeToolName}.ts`,
                content: generateSingleToolFileContent(tool)
            };
        });

        // 3. Populate Preview - Removed

        // 4. Store generated data for zipping
        generatedFilesData = {
            serverName: serverInfo.name || 'my-mcp-server',
            readme: readmeContent,
            packageJson: packageJsonContent,
            tsconfig: tsconfigJsonContent,
            indexTs: indexTsContent,
            toolFiles: toolFiles // Store array of tool files
        };

        // 5. Show the Download All button
        downloadAllButton.style.display = 'inline-block'; // Or 'block' depending on desired layout

    } catch (error) {
        console.error("Error generating files:", error);
        alert("An error occurred during file generation. Check the console for details.");
        // Display error in a more robust way if needed, e.g., dedicated error div
        const summaryDiv = document.getElementById('summary'); // Example: show error near summary
        if (summaryDiv) {
             summaryDiv.innerHTML = '<p style="color: red;">Error generating files: ' + (error instanceof Error ? error.message : String(error)) + '</p>';
        }
        generatedFilesData = null; // Ensure no partial data is available for download
        downloadAllButton.style.display = 'none'; // Hide button on error
    }
}

// Function to download all files as a zip
function downloadAllFiles() {
    if (!generatedFilesData) {
        alert("Please generate the files first.");
        return;
    }
    if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
        alert("Error: Required libraries (JSZip or FileSaver) not loaded.");
        console.error("JSZip or FileSaver not found. Make sure they are included in the HTML.");
        return;
    }

    console.log("Creating zip file...");
    try {
        const zip = new JSZip();
        const safeServerName = generatedFilesData.serverName.replace(/[^a-z0-9_-]/gi, '_'); // Sanitize name for zip file

        // Add files to zip
        zip.file("README.md", generatedFilesData.readme);
        zip.file("package.json", generatedFilesData.packageJson);
        zip.file("tsconfig.json", generatedFilesData.tsconfig);
        // Create src directory and add index.ts and individual tool files
        const srcFolder = zip.folder("src");
        if (srcFolder) {
            srcFolder.file("index.ts", generatedFilesData.indexTs);
            // Add each tool file from the stored array
            generatedFilesData.toolFiles.forEach(toolFile => {
                // Extract just the filename part for the zip entry
                const zipFilename = toolFile.filename.substring(toolFile.filename.lastIndexOf('/') + 1);
                srcFolder.file(zipFilename, toolFile.content);
            });
        } else {
             throw new Error("Could not create src folder in zip.");
        }

        // Generate the zip file asynchronously
        zip.generateAsync({ type: "blob" })
            .then(function(content) {
                // Trigger download using FileSaver.js
                saveAs(content, safeServerName + "_mcp_server.zip");
                console.log("Zip file download initiated.");
            })
            .catch(function (err) {
                console.error("Error generating zip file:", err);
                alert("Error creating zip file: " + err.message);
            });
    } catch (error) {
        console.error("Error during zipping process:", error);
        alert("An unexpected error occurred while creating the zip file.");
    }
}
