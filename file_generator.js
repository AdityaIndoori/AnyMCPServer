// Function to generate README content using string joining
function generateReadmeContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name || 'my-mcp-server';
    const lines = [
        `# ${safeServerName} - MCP Server`,
        '',
        'This MCP server was generated by the MCP Server Generator web application.',
        '',
        '## Files Included',
        '',
        '*   `package.json`: Defines project metadata, dependencies, and scripts.',
        '*   `tsconfig.json`: Configures the TypeScript compiler.',
        '*   `src/index.ts`: The main server entry point (usually no edits needed here).',
        '*   `src/tool_logic.ts`: **Implement your custom tool logic in this file.**',
        '',
        '## Getting Started',
        '',
        'Follow these steps to complete and run your server:',
        '',
        '**1. Setup:**',
        '',
        '*   Ensure you have [Node.js](https://nodejs.org/) (version 18 or higher recommended) and npm installed.',
        '*   Place the downloaded `index.ts` file inside the `src/` directory within this project folder.',
        '*   Open a terminal or command prompt in this project folder.',
        '*   Run `npm install` to download the necessary dependencies (@modelcontextprotocol/sdk, zod, typescript, etc.).',
        '',
        '**2. Implement Tool Logic:**',
        '',
        '*   Open `src/tool_logic.ts` in your code editor.',
        '*   Find the handler function for each tool you defined (e.g., `handle_yourToolName`).',
        '*   Replace the placeholder logic within each handler function with your actual code.',
        '',
        '*   **Return Value:** Each handler function *must* return a Promise resolving to an object matching the MCP specification:',
        '    *   **On Success:** Return `{ content: [{ type: "text", text: "Your result here" }], isError: false }`,', // The `content` array can hold different types as per the spec, but text is common.
        '    *   **On Failure:** Return `{ content: [{ type: "text", text: "Error description here" }], isError: true }`.',
        '',
        '**3. Build the Server:**',
        '',
        '*   Run `npm run build`. This command uses TypeScript (`tsc`) to compile your code from `src/index.ts` into JavaScript in the `build/` directory.',
        '',
        '**4. Run the Server:**',
        '',
        '*   Run `npm run start`.',
        '*   You should see a message like "' + safeServerName + ' MCP Server (v' + (serverInfo.version || '0.1.0') + ') running on stdio".',
        '*   The server is now running and waiting for an MCP client (like Claude Desktop) to connect via standard input/output.',
        '',
        '**5. Connecting to a Client (Example: Claude Desktop):**',
        '',
        '*   To use this server with Claude Desktop, you need to add it to the Claude configuration file (`claude_desktop_config.json`). See the [MCP Quickstart for Claude Users](https://modelcontextprotocol.io/quickstart/user) or [Server Developers](https://modelcontextprotocol.io/quickstart/server) for details on how to configure the `command` and `args` to run your server (using `node build/index.js` or potentially `npm run start` depending on your setup). Remember to use the **absolute path** to your project directory in the configuration.'
    ];

    return lines.join('\n');
}

// Function to generate index.ts content using string joining/concatenation
function generateIndexTsContent(serverInfo, toolsData) {
    const safeServerName = serverInfo.name?.replace(/"/g, '\\"') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version?.replace(/"/g, '\\"') || '0.1.0';

    const header = [
        '#!/usr/bin/env node',
        'import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
        'import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";',
        toolsData.length > 0 ? 'import { z } from "zod";' : '',
        // Import handlers from the dedicated logic file (using .js extension for compiled output)
        toolsData.length > 0 ? 'import { toolHandlers } from "./tool_logic.js";' : '',
        '',
        'const server = new McpServer({',
        '    name: "' + safeServerName + '",',
        '    version: "' + safeServerVersion + '",',
        '    capabilities: {',
        '        resources: {}, // Add resource capabilities if needed later',
        '        tools: {},     // Tool capabilities enabled by default when tools are added',
        '    },',
        '});',
        '',
        '// --- Tool Definitions ---',
        ''
    ];

    const toolDefinitions = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/"/g, '\\"') || 'unnamed_tool';
        const safeToolDesc = tool.description?.replace(/"/g, '\\"') || 'No description';
        let schemaParts = [];

        tool.params.forEach(param => {
            const safeParamName = param.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_param';
            let zodType;
            switch (param.type) {
                case 'number': zodType = 'z.number()'; break;
                case 'boolean': zodType = 'z.boolean()'; break;
                case 'string':
                default: zodType = 'z.string()'; break;
            }
            if (!param.required) {
                zodType += '.optional()';
            }
            schemaParts.push('    ' + safeParamName + ': ' + zodType);
        });

        const schemaString = schemaParts.length > 0 ? '{\n' + schemaParts.join(',\n') + '\n}' : '{}';
        const toolHandler = [
            'server.tool(',
            '    "' + safeToolName + '",',
            '    "' + safeToolDesc + '",',
            '    ' + schemaString + ',',
            '    // Call the corresponding handler from tool_logic.js',
            '    async (args: any) => {',
            '        if (!toolHandlers || typeof toolHandlers["' + safeToolName + '"] !== "function") {',
            '           console.error(`Handler for tool ${' + safeToolName + '} not found or not a function in tool_logic.js`);',
            '           return { content: [{ type: "text", text: `Internal server error: Handler for ${' + safeToolName + '} is missing.` }], isError: true };',
            '        }',
            '        // Directly call the imported handler',
            '        return await toolHandlers["' + safeToolName + '"](args);',
            '    }',
            ');',
            ''
        ];
        return toolHandler.join('\n');
    });

    const footer = [
        '',
        '// --- Server Startup ---',
        'async function main() {',
        '    const transport = new StdioServerTransport();',
        '    try {',
        '        await server.connect(transport);',
        '        console.error("' + safeServerName + ' MCP Server (v' + safeServerVersion + ') running on stdio");',
        '    } catch (error) {',
        '        console.error("Failed to connect server:", error);',
        '        process.exit(1);',
        '    }',
        '}',
        '',
        'main().catch((error) => {',
        '    console.error("Fatal error:", error);',
        '    process.exit(1);',
        '});',
        ''
    ];

    return header.join('\n') + toolDefinitions.join('\n') + footer.join('\n');
}

// Function to generate package.json content
function generatePackageJsonContent(serverInfo) {
    const safeServerName = serverInfo.name?.toLowerCase().replace(/[^a-z0-9-]/g, '-') || 'my-mcp-server';
    const safeServerVersion = serverInfo.version || '0.1.0';

    const content = {
        name: safeServerName,
        version: safeServerVersion,
        type: "module",
        description: "MCP server '" + (serverInfo.name || 'N/A') + "' generated by MCP Server Generator",
        main: "build/index.js",
        bin: {
            [safeServerName]: "./build/index.js"
        },
        scripts: {
            "build": "tsc",
            "start": "node build/index.js"
        },
        dependencies: {
            "@modelcontextprotocol/sdk": "^1.7.0",
            "zod": "^3.23.8"
        },
        devDependencies: {
            "typescript": "^5.4.5",
            "@types/node": "^20.12.12"
        },
        engines: {
            "node": ">=18.0.0"
        },
        author: "MCP Server Generator",
        license: "ISC"
    };
    return JSON.stringify(content, null, 2);
}

// Function to generate src/tool_logic.ts content
function generateToolLogicTsContent(toolsData) {
    const handlers = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_tool';
        const paramNames = tool.params.map(p => p.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_param');
        // Generate a basic Zod-like type hint string for the comment
        const paramsTypeHint = tool.params.map(p => `${p.name?.replace(/[^a-zA-Z0-9_]/g, '_')}${p.required ? '' : '?'}: ${p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string'}`).join(', ');
        const argsSignature = tool.params.length > 0 ? `{ ${paramNames.join(', ')} }: { ${paramsTypeHint} }` : 'args: any';

        return `
/**
 * Handler function for the '${safeToolName}' tool.
 * @param ${argsSignature} - The arguments passed to the tool, matching the defined parameters.
 * @returns {Promise<{ content: { type: string, text: string }[], isError: boolean }>} - The result or error object.
 */
async function handle_${safeToolName}(${argsSignature}) {
    console.log("Executing tool logic for '${safeToolName}' with input:", ${tool.params.length > 0 ? `{ ${paramNames.join(', ')} }` : 'args'});

    // --- IMPLEMENT YOUR TOOL LOGIC FOR '${safeToolName}' HERE ---
    // Access parameters directly (e.g., ${paramNames[0] || 'param1'}).
    // Remember to handle potential errors using try...catch.
    // Return an object like:
    //   { content: [{ type: "text", text: "Success result" }], isError: false }
    // or on error:
    //   { content: [{ type: "text", text: "Error message" }], isError: true }

    try {
        // Example placeholder logic: Replace this with your actual implementation.
        const placeholderResult = "Successfully executed ${safeToolName} with params: " + JSON.stringify(${tool.params.length > 0 ? `{ ${paramNames.join(', ')} }` : 'args'});

        // Simulate async operation if needed
        // await new Promise(resolve => setTimeout(resolve, 100));

        return {
            content: [{ type: "text", text: placeholderResult }],
            isError: false
        };

    } catch (error) {
        console.error("Error in tool '${safeToolName}':", error);
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
        return {
            content: [{ type: "text", text: \`Error executing ${safeToolName}: \${errorMessage}\` }],
            isError: true
        };
    }
    // --- END TOOL LOGIC ---
}`;
    });

    const exportLines = toolsData.map(tool => {
        const safeToolName = tool.name?.replace(/[^a-zA-Z0-9_]/g, '_') || 'unnamed_tool';
        // Use the actual tool name as the key in the exported object
        return `    "${tool.name || 'unnamed_tool'}": handle_${safeToolName},`;
    });

    const header = [
        '// src/tool_logic.ts',
        '// This file is where you implement the logic for your MCP server tools.',
        '',
        '// Import any necessary modules here',
        '// Example: import fs from \'fs/promises\';',
        '',
        '// Define types for tool arguments if needed for better type safety',
        '// Example: type MyToolArgs = { name: string; count?: number };',
        '',
    ];

    const footer = [
        '',
        '// Export all handlers wrapped in an object.',
        '// The keys MUST match the tool names defined in the MCP server setup (index.ts).',
        'export const toolHandlers = {',
        ...exportLines,
        '};',
        '',
    ];

    // Handle case where no tools are defined
    if (toolsData.length === 0) {
        return header.join('\n') + '\n// No tools defined. Add tools via the generator or manually implement handlers here and update index.ts.\n' + footer.join('\n');
    }

    return header.join('\n') + handlers.join('\n\n') + footer.join('\n');
}


// Function to generate tsconfig.json content
function generateTsconfigJsonContent() {
    const content = {
        compilerOptions: {
            target: "ES2022",
            module: "Node16",
            moduleResolution: "Node16",
            outDir: "./build",
            rootDir: "./src",
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
        },
        include: ["src/**/*"],
        exclude: ["node_modules", "build"]
    };
    return JSON.stringify(content, null, 2);
}

// Global variable to store generated file data for zipping
let generatedFilesData = null;

// Main function to generate all files
function generateFiles() {
    console.log("Gathering data and generating files...");
    // const downloadLinksDiv = document.getElementById('download-links'); // No longer needed for links
    const indexTsPreview = document.getElementById('index-ts-preview');
    const downloadAllButton = document.getElementById('download-all-button'); // Get the new button

    if (!indexTsPreview || !downloadAllButton) { // Check for new button
        console.error("Required elements (index-ts-preview or download-all-button) not found.");
        return;
    }
    // downloadLinksDiv.innerHTML = ''; // Clear previous links - No longer needed
    indexTsPreview.value = ''; // Clear preview
    downloadAllButton.style.display = 'none'; // Hide button initially
    generatedFilesData = null; // Reset stored data

    // 1. Gather Data
    const serverNameInput = document.getElementById('server-name');
    const serverVersionInput = document.getElementById('server-version');

    const serverInfo = {
        name: serverNameInput ? serverNameInput.value.trim() : 'my-mcp-server',
        version: serverVersionInput ? serverVersionInput.value.trim() : '0.1.0'
    };
     if (!serverInfo.name) {
        alert("Server Name cannot be empty.");
        downloadLinksDiv.innerHTML = '<p style="color: red;">Server Name cannot be empty.</p>';
        return;
    }

    const toolsData = [];
    document.querySelectorAll('.tool-definition').forEach(toolDiv => {
        const toolId = toolDiv.id;
        const toolNameInput = document.getElementById(toolId + '-name'); // Fixed template literal issue
        const toolDescInput = document.getElementById(toolId + '-desc'); // Fixed template literal issue
        const tool = {
            name: toolNameInput ? toolNameInput.value.trim() : 'tool_' + toolId, // Fixed template literal issue
            description: toolDescInput ? toolDescInput.value.trim() : '',
            params: []
        };
        if (!tool.name) {
            alert('Tool name for Tool ' + toolId.split('-')[1] + ' cannot be empty.'); // Fixed template literal issue
            tool.name = 'invalid_tool_' + toolId; // Fixed template literal issue
        }

        toolDiv.querySelectorAll('.parameter-definition').forEach(paramDiv => {
            const paramId = paramDiv.id;
            const paramNameInput = document.getElementById(paramId + '-name'); // Fixed template literal issue
            const paramTypeSelect = document.getElementById(paramId + '-type'); // Fixed template literal issue
            const paramRequiredCheckbox = document.getElementById(paramId + '-required'); // Fixed template literal issue

            const paramData = {
                name: paramNameInput ? paramNameInput.value.trim() : 'param_' + paramId, // Fixed template literal issue
                type: paramTypeSelect ? paramTypeSelect.value : 'string',
                required: paramRequiredCheckbox ? paramRequiredCheckbox.checked : true,
            };
            if (!paramData.name) {
                 alert('Parameter name for Param ' + paramId.split('-')[1] + ' in Tool \'' + tool.name + '\' cannot be empty.'); // Fixed template literal issue
                 paramData.name = 'invalid_param_' + paramId; // Fixed template literal issue
            }
            tool.params.push(paramData);
        });
        toolsData.push(tool);
    });

    // 2. Generate Content
    try {
        const indexTsContent = generateIndexTsContent(serverInfo, toolsData);
        // Removed duplicate declaration below
        const packageJsonContent = generatePackageJsonContent(serverInfo);
        const tsconfigJsonContent = generateTsconfigJsonContent();
        const readmeContent = generateReadmeContent(serverInfo, toolsData);
        const toolLogicTsContent = generateToolLogicTsContent(toolsData); // Generate new file content

        // 3. Populate Preview
        indexTsPreview.value = indexTsContent; // Keep previewing index.ts

        // 4. Store generated data for zipping
        generatedFilesData = {
            serverName: serverInfo.name || 'my-mcp-server',
            readme: readmeContent,
            packageJson: packageJsonContent,
            tsconfig: tsconfigJsonContent,
            indexTs: indexTsContent,
            toolLogicTs: toolLogicTsContent // Store new file content
        };

        // 5. Show the Download All button
        downloadAllButton.style.display = 'inline-block'; // Or 'block' depending on desired layout

    } catch (error) {
        console.error("Error generating files:", error);
        alert("An error occurred during file generation. Check the console for details.");
        // Display error in a more robust way if needed, e.g., dedicated error div
        const summaryDiv = document.getElementById('summary'); // Example: show error near summary
        if (summaryDiv) {
             summaryDiv.innerHTML = '<p style="color: red;">Error generating files: ' + (error instanceof Error ? error.message : String(error)) + '</p>';
        }
        generatedFilesData = null; // Ensure no partial data is available for download
        downloadAllButton.style.display = 'none'; // Hide button on error
    }
}

// Function to download all files as a zip
function downloadAllFiles() {
    if (!generatedFilesData) {
        alert("Please generate the files first.");
        return;
    }
    if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
        alert("Error: Required libraries (JSZip or FileSaver) not loaded.");
        console.error("JSZip or FileSaver not found. Make sure they are included in the HTML.");
        return;
    }

    console.log("Creating zip file...");
    try {
        const zip = new JSZip();
        const safeServerName = generatedFilesData.serverName.replace(/[^a-z0-9_-]/gi, '_'); // Sanitize name for zip file

        // Add files to zip
        zip.file("README.md", generatedFilesData.readme);
        zip.file("package.json", generatedFilesData.packageJson);
        zip.file("tsconfig.json", generatedFilesData.tsconfig);
        // Create src directory and add index.ts and tool_logic.ts inside it
        const srcFolder = zip.folder("src");
        if (srcFolder) {
            srcFolder.file("index.ts", generatedFilesData.indexTs);
            srcFolder.file("tool_logic.ts", generatedFilesData.toolLogicTs); // Add the new file
        } else {
             throw new Error("Could not create src folder in zip.");
        }


        // Generate the zip file asynchronously
        zip.generateAsync({ type: "blob" })
            .then(function(content) {
                // Trigger download using FileSaver.js
                saveAs(content, safeServerName + "_mcp_server.zip");
                console.log("Zip file download initiated.");
            })
            .catch(function (err) {
                console.error("Error generating zip file:", err);
                alert("Error creating zip file: " + err.message);
            });
    } catch (error) {
        console.error("Error during zipping process:", error);
        alert("An unexpected error occurred while creating the zip file.");
    }
}
